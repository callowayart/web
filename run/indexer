#!/usr/bin/env ruby
# Description: Migrates data from defunt callowayart database

# REQUIRE
require 'faraday'
require 'tire'
require 'json'
require 'RMagick'
require 'pp'
require 'aws/s3'
require 'uri'
require 'pathname'

# CONSTANTS


# FUNCTION / PATCHES

include Magick
include AWS::S3

$VERBOSE = nil


Base.establish_connection!(
	access_key_id:     ENV['AMAZON_ACCESS_KEY_ID'],	
	secret_access_key: ENV['AMAZON_SECRET_ACCESS_KEY']
)
@bucket = Bucket.find('callowayart.com') or raise "failed to find bucket callowayart.com"


class String
  def slugify
    self.downcase.strip.gsub(' ', '-').gsub(/[^\w-]/, '')
  end
end

module Kernel
  def with_cached_print
    save_so, $stdout = $stdout, StringIO.new(' ', 'w')
   
    yield if block_given?
   
    my_so, $stdout = $stdout, save_so
    my_so.string
  end
end

# save image to /tmp
def resize_image uri, options = { }

	# parse id, mime type from image uri
	format = uri.split('/').last.match(/\.(.+)$/)[1]
	id     = uri.split('/').last.sub(/\..+$/, '').slugify

	# resize image and save to /tmp
	image = Image.read(uri)[0]
	
	# calculate width/height based on percentage of 
	# difference of width from absolute value of 150
	if options[:width]
		width  = options[:width]
		scale  = (image.page.width - width) / image.page.width.to_f
		height = image.page.height - (image.page.height * scale)

		image = image.thumbnail(width, height)
		image.write(
			path = "/tmp/#{id}-constrainedw.#{format}"
		)		

	elsif options[:height]
		height = options[:height]
		scale  = (image.page.height - height) / image.page.height.to_f
		width  = image.page.width - (image.page.width * scale)

		image = image.thumbnail(width, height)
		image.write(
			path = "/tmp/#{id}-thumbh.#{format}"
		)

	else
		width  = 150
		scale  = (image.page.width - width) / image.page.width.to_f
		height = image.page.height - (image.page.height * scale)

		image = image.thumbnail(width, height)
		image.write(
			path = "/tmp/#{id}-thumb.#{format}"
		)

	end

  path
end

def save_to_s3 uri, path
	uri = URI(uri)

	# get domain and save path
	domain    = uri.scheme + '://callowayart.com.s3.amazonaws.com'
	save_path = File.dirname(uri.path) + '/' +
	            Pathname.new(path).basename.to_s
	
	# store s3
	S3Object.store( 
		save_path, open(path), 'callowayart.com', access: :public_read
	)

	# return reference 
	domain + save_path
end

# MAIN



# create rest client
rest = Faraday.new 'http://cms.callowayart.com'

# iterate through records
count = 0
limit = 100

loop do
	puts "processing images #{count * limit} through #{(count * limit) + limit}"

	index  = [ ] 
	images = JSON.parse(rest.get('/api/image', {
		offset: ((count += 1) - 1) * limit,
		limit:  limit,
		recent: ARGV[0] == 'recent' && 1 || 0
	}).body)

	# iterate through images, transform and import into 
	# elastic search
	images.each do | image |
		# in the event of images not being defined on amazon
		# we need to upload to s3 and reset 'full' uri
		unless image['full'] =~ /s3\.amazonaws/
			image['full'] = save_to_s3 image['full'], image['full']
		end

		# save the image file, resize and push to s3
		begin
			path  = resize_image image['full']
			thumb = save_to_s3   image['full'], path

			path   = resize_image image['full'],  height: 120
			thumbh = save_to_s3  image['full'], path

			path         = resize_image image['full'],  width: 600
			constrainedw = save_to_s3   image['full'], path		

		rescue Exception => ignore
			next
		end

		index << hash = {
			id:           image['id'],
			title:        image['title'],
			title_slug:   image['title'].slugify,
			description:  image['description'] || "description",
			artist:       image['artist'] || "unknown",
			uri:          image['full'],
			thumb:        thumb,
			thumbh:       thumbh,
			constrainedw: constrainedw, 
			tags:         image['tags'] || [ ],
			type:         'art',
			artist_description: image['artist_description'] || "artist-description"
		}

		# add unknown to tags if no artist has been specified
		unless image['artist']
			hash[:tags] << 'unknown'
			image['artist_slug'] = 'unknown'
		end

		# add last name if available
		*ignore, hash[:artist_last_name] = hash[:artist].split( ' ' )

		%w{ 
			artist_slug title_slug exhibit exhibit_slug exhibit_description

		}.each do | field |
			hash[field] = image[field] if image[field]
		end

	end

	Tire.index 'callowayart' do
		import index
	end

	break if images.count == 0
end

Dir.glob('/tmp/*.jpg').each { |f| File.delete(f) }

puts "done"
